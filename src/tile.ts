import { Lerp } from './lerp';
import { Color } from './color';

// Holds a representation of what a tile currently looks like.
class NRXTileState {
  public char = '?';
  public fgc = new Color(255, 0, 255);
  public bgc = new Color(255, 0, 255);
  public bga = 0.0;
  public rot = 0;
}

export class NRXTile {
  private _tileState: NRXTileState;
  public uncolored: boolean; // Is there a BG color already here that we should blend?
  public forceRedraw = false; // Set true to force a one-off repaint of this tile upon next redraw of the terminal

  constructor() {
    this._tileState = new NRXTileState();
    this.uncolored = true;
  }

  /**
   * Sets the background color to a new color generated by lerping the new and old colors by the given proportion.
   * @param  {number} newBgc The incoming background color to apply.
   * @param  {number} proportion Amount to lerp, where 0 = 100% current color, 1 = 100% new color. Valid range [0 ,1].
   * @returns {void}
   */
  public lerpBgc(r: number, g: number, b: number, proportion: number): void {
    if (proportion < 0 || proportion > 1) {
      throw new Error ('Attempted to lerp the background color by a proportion (' + proportion + ') outside the ' +
        'acceptable range [0, 1].');
    }

    this._tileState.bgc = Lerp.lerpColor(new Color(r, g, b), this._tileState.bgc, proportion);
  }

  /**
   * Sets the foreground (character) color to a new color generated by lerping the new and old colors by the given
   * proportion.
   * @param  {number} newFgc The incoming foreground color to apply.
   * @param  {number} proportion Amount to lerp, where 0 = 100% current color, 1 = 100% new color. Valid range [0 ,1].
   * @returns {void}
   */
  public lerpFgc(r: number, g: number, b: number, proportion: number): void {
    if (proportion < 0 || proportion > 1) {
      throw new Error ('Attempted to lerp the foreground color by a proportion (' + proportion + ') outside the ' +
        'acceptable range [0, 1].');
    }

    this._tileState.fgc = Lerp.lerpColor(new Color(r, g, b), this._tileState.fgc, proportion);
  }

  // Methods that allow the display characteristics of the tile to be modified.
  public setFgc(r: number, g: number, b: number): void {
    this._tileState.fgc.r = r;
    this._tileState.fgc.g = g;
    this._tileState.fgc.b = b;
  }
  public setBgc(r: number, g: number, b: number): void {
    this._tileState.bgc.r = r;
    this._tileState.bgc.g = g;
    this._tileState.bgc.b = b;
  }
  
  public setBga(bga: number): void { this._tileState.bga = bga; }
  public setChar(char: string): void { this._tileState.char = char; }

  // Rotation is in radians. Zero (or multiples of 2pi) equal no rotation. Positive rotation is counterclockwise.
  public setRot(rot: number): void { this._tileState.rot = rot; }

  get fgc(): Color { return this._tileState.fgc; }
  get bgc(): Color { return this._tileState.bgc; }
  get bga(): number { return this._tileState.bga; }
  get char(): string { return this._tileState.char; }
  get rot(): number { return this._tileState.rot; }
}
